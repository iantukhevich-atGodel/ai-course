<h1>Iterative Prompting and Refinement</h1>
<p>
	Even with good context, outputs may not be perfect on the first attempt. Iterative prompting involves feeding outputs back into the model with additional instructions or clarifications to refine results.
</p>
<ul>
	<b>Why it matters:</b>
	<li>
		 It allows the model to correct mistakes, expand on missing details, or adjust outputs according to constraints.
	</li>
	<li>
		In QA workflows, iterative prompting can be used to generate multiple levels of test cases, review coverage, or adjust for edge cases.
	</li>
</ul>
<ol>
	<b>Example:</b>
	<li>
		First prompt: “Generate test cases for password reset page.”
		<ul>
			<li>
				Output may cover only basic scenarios.
			</li>
		</ul>
	</li>
	<li>
		Refined prompt: “Review previous output and add edge cases for invalid emails, expired links, and multiple simultaneous requests.”
		<ul>
			<li>
				Model now produces a more comprehensive set of test cases.
			</li>
		</ul>
	</li>
</ol>
<p>
	Iterative prompting helps maintain context across multiple steps, effectively building a dialogue with the model that increases output accuracy and relevance.
</p>

<footer>
	{Image placeholder: Flow diagram showing initial prompt → model → refine prompt → model → improved output}
</footer>