<h1>Iterative Refinement</h1>
<p>
	Prompt debugging is rarely a one-step process. Iterative refinement involves adjusting the prompt based on observed failures and retesting until outputs meet requirements. This mirrors a QA mindset: observe, hypothesize, test, and adjust.
</p>
<ol>
	<b>Example Iteration:</b>
	<li>
		Original prompt:
		<div>
<pre><code>Generate test cases for the registration page.</code></pre>
		</div>
	</li>
	<li>
		Refinement 1: Add specificity and role:
		<div>
<pre><code>Act as a QA engineer. Generate 5 test cases for the registration page, including positive scenarios. Format output in a table with Input, Steps, Expected Result.</code></pre>
		</div>
	</li>
	<li>
		Refinement 2: Include negative scenarios and edge cases:
		<div>
<pre><code>Act as a QA engineer. Generate 5 positive and 5 negative test cases for the registration page, including edge cases such as blank fields, invalid emails, and password limits. Output in a table with Input, Steps, Expected Result.</code></pre>
		</div>
	</li>
</ol>
<p>
	Through this iterative process, the prompt becomes more robust and consistently generates complete, actionable outputs.
</p>
<p>
	<b>Tip:</b>
	Record each iteration and note what changed in the output. Over time, this builds a debugging methodology that can be applied to new prompts efficiently.
</p>

<footer>
	{Image placeholder: Flow showing prompt iteration 1 → output → prompt iteration 2 → improved output}
</footer>