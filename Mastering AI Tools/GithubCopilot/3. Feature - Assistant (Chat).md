<p>
	<a href='https://docs.github.com/en/copilot/concepts/chat'>Copilot Chat</a>
	is a conversational assistant inside your IDE and on GitHub.com that explains code, proposes tests, generates snippets, and answers “how do I” questions. It supports custom instructions at personal and repository levels so responses match your stack, conventions, and security posture. You can swap chat models as needed, choosing faster or more capable variants depending on the task. Chat extends further with Model Context Protocol (MCP) and Extensions, letting you bring tool and data context into answers. Think of it as a knowledgeable teammate who knows your code and docs.
</p>

<p>
	Start with small, concrete prompts that include the current file or selection. Ask for an explanation plus a minimal example, then request tests that lock the behavior. If Chat proposes a fix, follow up with “risks and mitigations” so you see potential regressions before accepting edits. Save durable guidance—like naming rules or logging levels—into custom instructions so you don’t have to repeat yourself. Over time, this builds a consistent voice and reduces rework.
</p>

<p>
	Repository instructions let you encode guardrails for everyone working in the repo. Include style preferences, dependency constraints, and any forbidden APIs, and ask Chat to cite the section it used when it gives advice. Personal instructions help you tune tone and depth across projects. Encourage the assistant to produce diffs and rationale instead of raw blobs for easier review. These practices make code review smoother and safer.
</p>

<p>
	Copilot Chat can be extended with MCP and Extensions to reach tools and knowledge outside your editor. Configure MCP servers to expose capabilities like GitHub operations or internal systems, and invoke extensions with <code>@</code> mentions for domain‑specific tasks. This reduces context switching and makes answers actionable in place. Keep the principle of least privilege and enable only what your team needs. Review logs and outputs just like any other automated system. 
</p>

<p>
	Exercise: pick a legacy function with unclear behavior. Ask Chat to explain it, propose a safer refactor, and generate tests that prove equivalence. Then add repo instructions that capture the decisions you just made so future prompts inherit them. Finish by asking for a short design note you can commit next to the change. This turns chat into documented engineering practice. 
</p>

<pre><code class="language-mermaid">
	flowchart LR
	  SEL[Select Code] --> ASK[Ask Copilot Chat]
	  ASK --> EXPL[Explain & Example]
	  EXPL --> TESTS[Generate Tests]
	  TESTS --> REFA[Refactor Proposal]
	  REFA --> DIFF[Review Diff & Rationale]
</code></pre>